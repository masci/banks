{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Banks","text":"<p>Banks is the linguist professor who will help you generate meaningful LLM prompts using a template language that makes sense.</p> <p>Prompts are instrumental for the success of any LLM application, and Banks focuses around specific areas of their lifecycle:</p> <ul> <li> Templating: Banks provides tools and functions to build prompts text and chat messages from generic blueprints.</li> <li> Versioning and metadata: Banks supports attaching metadata to prompts to ease their management, and versioning is first-class citizen.</li> <li> Management: Banks provides ways to store prompts on disk along with their metadata.</li> </ul> <p>Banks is fundamentally Jinja2 with additional functionalities specifically designed to work with Large Language Models prompts. Similar to other template languages, Banks takes in input a generic piece of text called template and gives you back its rendered version, where the generic bits are replaced by actual data provided by the user and returned in a form that's suitable for sending to an LLM, like plain text or chat messages.</p>"},{"location":"#features","title":"Features","text":"<p>Banks currently supports all the features from Jinja2 along with some additions specifically designed to help developers with LLM prompts:</p> <ul> <li>Filters: useful to manipulate the prompt text during template rendering.</li> <li>Extensions: useful to support custom functions (e.g. text generation via LiteLLM).</li> <li>Macros: useful to implement complex logic in the template itself instead of Python code.</li> </ul> <p>The library comes with its own set of features:</p> <ul> <li>Template registry: storage API for versioned prompts.</li> <li>Configuration: useful to integrate the library with existing applications.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install the latest version of Banks using <code>pip</code>:</p> <pre><code>pip install banks\n</code></pre> <p>Some functionalities require additional dependencies that need to be installed manually:</p> <ul> <li><code>pip install simplemma</code> is required by the <code>lemmatize</code> filter</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>If you like to jump straight to the code:</p> <ul> <li>See a showcase of basic examples here.</li> <li>Check out the Cookbook:</li> <li> In-prompt chat completion</li> <li> Prompt caching with Anthropic</li> <li> Prompt versioning</li> </ul>"},{"location":"#license","title":"License","text":"<p><code>banks</code> is distributed under the terms of the MIT license.</p>"},{"location":"config/","title":"Configuration","text":""},{"location":"config/#configuration","title":"Configuration","text":"<p>Banks can smoothly run with defaults, but you can configure the library by changing the <code>config</code> object or by setting the correspondent environment variables.</p> <p>Example usage:</p> <pre><code>from banks import config\n\n\nconfig.ASYNC_ENABLED = True\n</code></pre>"},{"location":"config/#async_enabled","title":"ASYNC_ENABLED","text":"Type: <code>bool</code> or truthy string Default value: <code>False</code> Env var: <code>BANKS_ASYNC_ENABLED</code> <p>Whether or not to use <code>asyncio</code> for prompt rendering and LLM generation. This setting won't speed up your application, only set it to <code>True</code> if you need to integrate Banks into an async codebase.</p>"},{"location":"config/#user_data_path","title":"USER_DATA_PATH","text":"Type: <code>Path</code> or path string Default value: depending on OS Env var: <code>BANKS_USER_DATA_PATH</code> <p>A user-writable folder where Banks will store its data. Banks uses a meaningful default for your operating system, so change it only if you have to.</p>"},{"location":"examples/","title":"Examples","text":"<p>Table of Contents</p> <ul> <li>Create a blog writing prompt</li> <li>Create a summarizer prompt</li> <li>Lemmatize text while processing a template</li> <li>Convert a JSON-like object into XML while processing the template</li> <li>Use a LLM to generate a text while rendering a prompt</li> <li>Render a prompt template as chat messages</li> <li>Use prompt caching from Anthropic</li> <li>Reuse templates from registries</li> <li>Async support</li> <li>Function calling directly from the prompt</li> <li>Add images to the prompt for vision models</li> </ul>"},{"location":"examples/#create-a-blog-writing-prompt","title":"Create a blog writing prompt","text":"<p>Given a generic template to instruct an LLM to generate a blog article, we use Banks to generate the actual prompt on our topic of choice, \"retrogame computing\":</p> <pre><code>from banks import Prompt\n\n\np = Prompt(\"Write a 500-word blog post on {{ topic }}.\\n\\nBlog post:\")\ntopic = \"retrogame computing\"\nprint(p.text({\"topic\": topic}))\n</code></pre> <p>This will print the following text, that can be pasted directly into Chat-GPT:</p> <pre><code>Write a 500-word blog post on retrogame computing.\n\nBlog post:\n</code></pre> <p>The same prompt can be written in form of chat messages: <pre><code>prompt_text = \"\"\"{% chat role=\"system\" %}\nI want you to act as a title generator for written pieces.\n{% endchat %}\n\n{% chat role=\"user\" %}\nWrite a 500-word blog post on {{ topic }}.\n\nBlog post:\n{% endchat %}\"\"\"\n\np = Prompt(prompt_text)\nprint(p.chat_messages({\"topic\":\"prompt engineering\"}))\n</code></pre></p> <p>This will output the following: <pre><code>[\n  ChatMessage(role='system', content='I want you to act as a title generator for written pieces.\\n'),\n  ChatMessage(role='user', content='Write a 500-word blog post on .\\n\\nBlog post:\\n')\n]\n</code></pre></p>"},{"location":"examples/#create-a-summarizer-prompt","title":"Create a summarizer prompt","text":"<p>Instead of hardcoding the content to summarize in the prompt itself, we can inject it starting from a generic one:</p> <pre><code>from banks import Prompt\n\n\nprompt_template = \"\"\"\nSummarize the following documents:\n{% for document in documents %}\n{{ document }}\n{% endfor %}\nSummary:\n\"\"\"\n\n# In a real-world scenario, these would be loaded as external resources from files or network\ndocuments = [\n    \"A first paragraph talking about AI\",\n    \"A second paragraph talking about climate change\",\n    \"A third paragraph talking about retrogaming\"\n]\n\np = Prompt(prompt_template)\nprint(p.text({\"documents\": documents}))\n</code></pre> <p>The resulting prompt:</p> <pre><code>Summarize the following documents:\n\nA first paragraph talking about AI\n\nA second paragraph talking about climate change\n\nA third paragraph talking about retrogaming\n\nSummary:\n</code></pre>"},{"location":"examples/#lemmatize-text-while-processing-a-template","title":"Lemmatize text while processing a template","text":"<p>Banks comes with predefined filters you can use to process data before generating the prompt. Say you want to use a lemmatizer on a document before summarizing it, first you need to install <code>simplemma</code>:</p> <pre><code>pip install simplemma\n</code></pre> <p>then you can use the <code>lemmatize</code> filter in your templates like this:</p> <pre><code>from banks import Prompt\n\n\nprompt_template = \"\"\"\nSummarize the following document:\n{{ document | lemmatize }}\nSummary:\n\"\"\"\n\np = Prompt(prompt_template)\nprint(p.text({\"document\": \"The cats are running\"}))\n</code></pre> <p>the output would be:</p> <pre><code>Summarize the following document:\nthe cat be run\nSummary:\n</code></pre>"},{"location":"examples/#convert-a-json-like-object-into-xml-while-processing-the-template","title":"Convert a JSON-like object into XML while processing the template","text":"<p>Banks has built-in support for filtering JSON-like objects (Pydantic <code>BaseModel</code> subclasses, dictionaries, deserializable strings) and returning an XML string. </p> <p>Here is an example of how you can use it:</p> <pre><code>from banks import Prompt\nfrom pydantic import BaseModel\nfrom typing import Dict\n\nprompt_template = \"\"\"\nPlease extract the contact details from this user:\n\n{{ data | to_xml }}\n\nContact details:\n\"\"\"\n\nclass User(BaseModel):\n    username: str\n    account_id: str\n    registered_at: str\n    email: str\n    phone_number: str\n    social_media_accounts: Dict[str, str]\n\nuser = User(username=\"example\", account_id=\"0000\", registered_at=\"10-25-2024\", email=\"example@email.com\", phone_number=\"0123456789\", social_media_accounts={\"BlueSky\": \"@example.com\"})\n\np = Prompt(prompt_template)\nprint(p.text({\"data\": user}))\n</code></pre> <p>This will output:</p> <pre><code>Please extract the contact details from this user:\n\n&lt;user&gt;\n    &lt;username&gt;example&lt;/username&gt;\n    &lt;account_id&gt;0000&lt;/account_id&gt;\n    &lt;registered_at&gt;10-25-2024&lt;/registered_at&gt;\n    &lt;email&gt;example@email.com&lt;/email&gt;\n    &lt;phone_number&gt;0123456789&lt;/phone_number&gt;\n    &lt;social_media_accounts&gt;{'BlueSky': '@example.com'}&lt;/social_media_accounts&gt;\n&lt;/user&gt;\n\n\nContact details:\n</code></pre>"},{"location":"examples/#use-a-llm-to-generate-a-text-while-rendering-a-prompt","title":"Use a LLM to generate a text while rendering a prompt","text":"<p>Sometimes it might be useful to ask another LLM to generate examples for you in a few-shots prompt. Provided you have a valid OpenAI API key stored in an env var called <code>OPENAI_API_KEY</code> you can ask Banks to do something like this (note we can annotate the prompt using comments - anything within <code>{# ... #}</code> will be removed from the final prompt):</p> <pre><code>from banks import Prompt\n\n\nprompt_template = \"\"\"\n{% set examples %}\n{% completion model=\"gpt-3.5-turbo-0125\" %}\n  {% chat role=\"system\" %}You are a helpful assistant{% endchat %}\n  {% chat role=\"user\" %}Generate a bullet list of 3 tweets with a positive sentiment.{% endchat %}\n{% endcompletion %}\n{% endset %}\n\n{# output the response content #}\nGenerate a tweet about the topic {{ topic }} with a positive sentiment.\nExamples:\n{{ examples }}\n\"\"\"\n\np = Prompt(prompt_template)\nprint(p.text({\"topic\": \"climate change\"}))\n</code></pre> <p>The output would be something similar to the following: <pre><code>Generate a tweet about the topic climate change with a positive sentiment.\nExamples:\n- \"Feeling grateful for the sunshine today! \ud83c\udf1e #thankful #blessed\"\n- \"Just had a great workout and feeling so energized! \ud83d\udcaa #fitness #healthyliving\"\n- \"Spent the day with loved ones and my heart is so full. \ud83d\udc95 #familytime #grateful\"\n</code></pre></p> <p>[!IMPORTANT] The <code>completion</code> extension uses LiteLLM under the hood, and provided you have the proper environment variables set, you can use any model from the supported model providers.</p> <p>[!NOTE] Banks uses a cache to avoid generating text again for the same template with the same context. By default the cache is in-memory but it can be customized.</p>"},{"location":"examples/#render-a-prompt-template-as-chat-messages","title":"Render a prompt template as chat messages","text":"<p>You'll find yourself feeding an LLM a list of chat messages instead of plain text more often than not. Banks will help you remove the boilerplate by defining the messages already at the prompt level.</p> <pre><code>from banks import Prompt\n\n\nprompt_template = \"\"\"\n{% chat role=\"system\" %}\nYou are a {{ persona }}.\n{% endchat %}\n\n{% chat role=\"user\" %}\nHello, how are you?\n{% endchat %}\n\"\"\"\n\np = Prompt(prompt_template)\nprint(p.chat_messages({\"persona\": \"helpful assistant\"}))\n\n# Output:\n# [\n#   ChatMessage(role='system', content='You are a helpful assistant.\\n'),\n#   ChatMessage(role='user', content='Hello, how are you?\\n')\n# ]\n</code></pre>"},{"location":"examples/#use-prompt-caching-from-anthropic","title":"Use prompt caching from Anthropic","text":"<p>Several inference providers support prompt caching to save time and costs, and Anthropic in particular offers fine-grained control over the parts of the prompt that we want to cache. With Banks this is as simple as using a template filter:</p> <pre><code>prompt_template = \"\"\"\n{% chat role=\"user\" %}\nAnalyze this book:\n\n{# Only this part of the chat message (the book content) will be cached #}\n{{ book | cache_control(\"ephemeral\") }}\n\nWhat is the title of this book? Only output the title.\n{% endchat %}\n\"\"\"\n\np = Prompt(prompt_template)\nprint(p.chat_messages({\"book\":\"This is a short book!\"}))\n\n# Output:\n# [\n#   ChatMessage(role='user', content=[\n#      ContentBlock(type='text', text='Analyze this book:\\n\\n'),\n#      ContentBlock(type='text', cache_control=CacheControl(type='ephemeral'), text='This is a short book!'),\n#      ContentBlock(type='text', text='\\n\\nWhat is the title of this book? Only output the title.\\n')\n#   ])\n# ]\n</code></pre>"},{"location":"examples/#reuse-templates-from-registries","title":"Reuse templates from registries","text":"<p>We can get the same result as the previous example loading the prompt template from a registry instead of hardcoding it into the Python code. For convenience, Banks comes with a few registry types you can use to store your templates. For example, the <code>DirectoryTemplateRegistry</code> can load templates from a directory in the file system. Suppose you have a folder called <code>templates</code> in the current path, and the folder contains a file called <code>blog.jinja</code>. You can load the prompt template like this:</p> <pre><code>from banks.registries import directory\n\npopulated_dir=\"./templates/\"\nregistry = directory.DirectoryTemplateRegistry(populated_dir)\nprompt = registry.get(name=\"blog\")\n\nprint(prompt.text({\"topic\": \"retrogame computing\"}))\n</code></pre>"},{"location":"examples/#async-support","title":"Async support","text":"<p>To run banks within an <code>asyncio</code> loop you have to do two things: 1. set the environment variable <code>BANKS_ASYNC_ENABLED=true</code>. 2. use the <code>AsyncPrompt</code> class that has an awaitable <code>run</code> method.</p> <p>Example: <pre><code>from banks import AsyncPrompt\n\nasync def main():\n    p = AsyncPrompt(\"Write a blog article about the topic {{ topic }}\")\n    result = await p.text({\"topic\": \"AI frameworks\"})\n    print(result)\n\nasyncio.run(main())\n</code></pre></p>"},{"location":"examples/#function-calling-directly-from-the-prompt","title":"Function calling directly from the prompt","text":"<p>Banks provides a filter <code>tool</code> that can be used to convert a callable passed to a prompt into an LLM function call. Docstrings are used to describe the tool and its arguments, and during prompt rendering Banks will perform all the LLM roundtrips needed in case the model wants to use a tool within a <code>{% completion %}</code> block. For example:</p> <pre><code>import platform\n\nfrom banks import Prompt\n\n\ndef get_laptop_info():\n    \"\"\"Get information about the user laptop.\n\n    For example, it returns the operating system and version, along with hardware and network specs.\"\"\"\n    return str(platform.uname())\n\n\np = Prompt(\"\"\"\n{% set response %}\n{% completion model=\"gpt-3.5-turbo-0125\" %}\n    {% chat role=\"user\" %}{{ query }}{% endchat %}\n    {{ get_laptop_info | tool }}\n{% endcompletion %}\n{% endset %}\n\n{# the variable 'response' contains the result #}\n\n{{ response }}\n\"\"\")\n\nprint(p.text({\"query\": \"Can you guess the name of my laptop?\", \"get_laptop_info\": get_laptop_info}))\n# Output:\n# Based on the information provided, the name of your laptop is likely \"MacGiver.\"\n</code></pre>"},{"location":"examples/#add-images-to-the-prompt-for-vision-models","title":"Add images to the prompt for vision models","text":"<p>If you're working with a multimodal model, you can include images directly in the prompt, and Banks will do the job needed to upload them when rendering the chat messages:</p> <pre><code>import litellm\n\nfrom banks import Prompt\n\nprompt_template = \"\"\"\n{% chat role=\"user\" %}\nGuess where is this place.\n{{ picture | image }}\n{%- endchat %}\n\"\"\"\n\npic_url = (\n    \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/CorcianoMar302024_01.jpg/1079px-CorcianoMar302024_01.jpg\"\n)\n# Alternatively, load the image from disk\n# pic_url = \"/Users/massi/Downloads/CorcianoMar302024_01.jpg\"\n\np = Prompt(prompt_template)\nas_dict = [msg.model_dump(exclude_none=True) for msg in p.chat_messages({\"picture\": pic_url})]\nr = litellm.completion(model=\"gpt-4-vision-preview\", messages=as_dict)\n\nprint(r.choices[0].message.content)\n</code></pre>"},{"location":"prompt/","title":"Prompt API","text":""},{"location":"prompt/#filters","title":"Filters","text":"<p>Filters are Python functions that are called during the rendering of a certain tag. For example, if a prompt template contains the tag:</p> <pre><code>{{ 'hello' | upper }}\n</code></pre> <p>a Python function named <code>upper</code> (in this case provided by Jinja) will be called passing the string 'hello' as a parameter, and its return value will replace the tag in the final text:</p> <pre><code>from banks import Prompt\n\np = Prompt(\"{{ 'hello' | upper }}\")\np.text()  ## outputs 'HELLO'\n</code></pre> <p>In addition to all the builtin filters provided by Jinja, Banks supports the following ones, specific for prompt engineering.</p>"},{"location":"prompt/#banks.filters.tool.tool","title":"tool","text":"<pre><code>tool(function)\n</code></pre> <p>Inspect a Python callable and generates a JSON-schema ready for LLM function calling.</p> Important <p>This filter only works when used within a <code>{% completion %}</code> block.</p>"},{"location":"prompt/#banks.filters.cache_control.cache_control","title":"cache_control","text":"<pre><code>cache_control(value, cache_type='ephemeral')\n</code></pre> <p>Wrap the filtered value into a ContentBlock with the proper cache_control field set.</p> <p>The resulting ChatMessage will have the field <code>content</code> populated with a list of ContentBlock objects.</p> Example <pre><code>{{ \"This is a long, long text\" | cache_control(\"ephemeral\") }}\n\nThis is short and won't be cached.\n</code></pre> Important <p>this filter marks the content to cache by surrounding it with <code>&lt;content_block&gt;</code> and <code>&lt;/content_block&gt;</code>, so it's only useful when used within a <code>{% chat %}</code> block.</p>"},{"location":"prompt/#banks.filters.image.image","title":"image","text":"<pre><code>image(value)\n</code></pre> <p>Wrap the filtered value into a ContentBlock of type image.</p> <p>The resulting ChatMessage will have the field <code>content</code> populated with a list of ContentBlock objects.</p> Example <pre><code>Describe what you see\n\n{{ \"path/to/image/file\" | image }}\n</code></pre> Important <p>this filter marks the content to cache by surrounding it with <code>&lt;content_block&gt;</code> and <code>&lt;/content_block&gt;</code>, so it's only useful when used within a <code>{% chat %}</code> block.</p>"},{"location":"prompt/#banks.filters.lemmatize.lemmatize","title":"lemmatize","text":"<pre><code>lemmatize(text)\n</code></pre> <p>Compute and return the lemmatization of the input. Language is hardcoded to English.</p> Example <pre><code>{{\"The dog is running\" | lemmatize}}\n\"the dog be run\"\n</code></pre> Note <p>Simplemma must be manually installed to use this filter</p>"},{"location":"prompt/#extensions","title":"Extensions","text":"<p>Extensions are custom functions that can be used to add new tags to the template engine. Banks supports the following ones, specific for prompt engineering.</p>"},{"location":"prompt/#banks.extensions.docs.chat","title":"chat","text":"<pre><code>chat(role)\n</code></pre> <p>Text inside <code>chat</code> tags will be rendered as JSON strings representing chat messages. Calling <code>Prompt.chat_messages</code> will return a list of <code>ChatMessage</code> instances.</p> Example <pre><code>{% chat role=\"system\" %}\nYou are a helpful assistant.\n{% endchat %}\n\n{% chat role=\"user\" %}\nHello, how are you?\n{% endchat %}\n</code></pre>"},{"location":"prompt/#banks.extensions.docs.completion","title":"completion","text":"<pre><code>completion(model_name)\n</code></pre> <p><code>completion</code> can be used to send to the LLM the content of the block in form of messages.</p> <p>The rendered value of the block can be assigned to a variable and accessed from another section of the prompt.</p> Example <pre><code>{% set response %}\n{% completion model=\"gpt-3.5-turbo-0125\" %}\n{% chat role=\"user\" %}You are a helpful assistant{% endchat %}\n{% endcompletion %}\n{% endset %}\n\n{# output the response content #}\n{{ response }}\n</code></pre>"},{"location":"prompt/#canary_word","title":"<code>canary_word</code>","text":"<p>Insert into the prompt a canary word that can be checked later with <code>Prompt.canary_leaked()</code> to ensure the original prompt was not leaked.</p> <p>Example:     <pre><code>from banks import Prompt\n\np = Prompt(\"{{canary_word}}Hello, World!\")\np.text()  ## outputs 'BANKS[5f0bbba4]Hello, World!'\n</code></pre></p>"},{"location":"prompt/#macros","title":"Macros","text":"<p>Macros are a way to implement complex logic in the template itself, think about defining functions but using Jinja code instead of Python. Banks provides a set of macros out of the box that are useful in prompt engineering, for example to generate a prompt and call OpenAI on-the-fly, during the template rendering. Before using Banks' macros, you have to import them in your templates, see the examples below.</p>"},{"location":"python/","title":"Python API","text":""},{"location":"python/#banks.prompt.Prompt","title":"banks.prompt.Prompt","text":"<p>The <code>Prompt</code> class is the only thing you need to know about Banks on the Python side. The class can be initialized with a string variable containing the prompt template text, then you can invoke the method <code>text</code> on your instance to pass the data needed to render the template and get back the final prompt.</p> <p>A quick example: <pre><code>from banks import Prompt\n\n\np = Prompt(\"Write a 500-word blog post on {{ topic }}.\")\nmy_topic = \"retrogame computing\"\nprint(p.text({\"topic\": my_topic}))\n</code></pre></p>"},{"location":"python/#banks.prompt.Prompt.raw","title":"raw  <code>property</code>","text":"<pre><code>raw: str\n</code></pre> <p>Returns the raw text of the prompt.</p>"},{"location":"python/#banks.prompt.Prompt.__init__","title":"__init__","text":"<pre><code>__init__(text: str, *, name: str | None = None, version: str | None = None, metadata: dict[str, Any] | None = None, canary_word: str | None = None, render_cache: RenderCache | None = None) -&gt; None\n</code></pre> <p>Prompt constructor.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The template text.</p> required <code>name</code> <code>str | None</code> <p>The name to identify this prompt.</p> <code>None</code> <code>version</code> <code>str | None</code> <p>The version string attached to this prompt.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>A key-value set of metadata pairs attached to this prompt.</p> <code>None</code> <code>canary_word</code> <code>str | None</code> <p>The string to use for the <code>{{canary_word}}</code> extension. If <code>None</code>, a default string will be generated.</p> <code>None</code> <code>render_cache</code> <code>RenderCache | None</code> <p>The caching backend to store rendered prompts. If <code>None</code>, the default in-memory backend will be used.</p> <code>None</code>"},{"location":"python/#banks.prompt.Prompt.canary_leaked","title":"canary_leaked","text":"<pre><code>canary_leaked(text: str) -&gt; bool\n</code></pre> <p>Returns whether the canary word is present in <code>text</code>, signalling the prompt might have leaked.</p>"},{"location":"python/#banks.prompt.Prompt.chat_messages","title":"chat_messages","text":"<pre><code>chat_messages(data: dict[str, Any] | None = None) -&gt; list[ChatMessage]\n</code></pre> <p>Render the prompt using variables present in <code>data</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any] | None</code> <p>A dictionary containing the context variables.</p> <code>None</code>"},{"location":"python/#banks.prompt.Prompt.text","title":"text","text":"<pre><code>text(data: dict[str, Any] | None = None) -&gt; str\n</code></pre> <p>Render the prompt using variables present in <code>data</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any] | None</code> <p>A dictionary containing the context variables.</p> <code>None</code>"},{"location":"python/#banks.prompt.AsyncPrompt","title":"banks.prompt.AsyncPrompt","text":"<p>Banks provides async support through the machinery provided by Jinja</p> <p>Since the Jinja environment is a global state in banks, the library can work either with or without async support, and this must be known before importing anything.</p> <p>If the application using banks runs within an <code>asyncio</code> loop, you can do two things to optimize banks' execution:</p> <ol> <li>Set the environment variable <code>BANKS_ASYNC_ENABLED=true</code>.</li> <li>Use the <code>AsyncPrompt</code> class that has an awaitable <code>run</code> method.</li> </ol> <p>For example, let's render a prompt that contains some calls to the <code>generate</code> extension. Those calls will be heavily I/O bound, so other tasks can take advantage and advance while the prompt is being rendered.</p> <p>Example: <pre><code># Enable async support before importing from banks\nimport os\n\nos.environ[\"BANKS_ASYNC_ENABLED\"] = \"true\"\n\n# Show logs to see what's happening at runtime\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\nimport asyncio\nfrom banks import AsyncPrompt\n\nprompt_template = \"\"\"\nGenerate a tweet about the topic '{{ topic }}' with a positive sentiment.\n\"\"\"\n\nasync def task(task_id: int, sleep_time: int):\n    logging.info(f\"Task {task_id} is running.\")\n    await asyncio.sleep(sleep_time)\n    logging.info(f\"Task {task_id} done.\")\n\n\nasync def main():\n    p = AsyncPrompt(prompt_template)\n    # Schedule the prompt rendering along with two executions of 'task', one sleeping for 10 seconds\n    # and one sleeping for 1 second\n    results = await asyncio.gather(p.text({\"topic\": \"AI frameworks\"}), task(1, 10), task(2, 1))\n    print(\"All tasks done, rendered prompt:\")\n    print(results[0])\n\n\nasyncio.run(main())\n</code></pre></p>"},{"location":"python/#banks.prompt.AsyncPrompt.text","title":"text  <code>async</code>","text":"<pre><code>text(data: dict[str, Any] | None = None) -&gt; str\n</code></pre> <p>Render the prompt using variables present in <code>data</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any] | None</code> <p>A dictionary containing the context variables.</p> <code>None</code>"},{"location":"python/#banks.registries.directory.DirectoryPromptRegistry","title":"banks.registries.directory.DirectoryPromptRegistry","text":"<p>Registry that stores prompts as files in a directory structure.</p>"},{"location":"python/#banks.registries.directory.DirectoryPromptRegistry.path","title":"path  <code>property</code>","text":"<pre><code>path: Path\n</code></pre> <p>Get the directory path where prompts are stored.</p>"},{"location":"python/#banks.registries.directory.DirectoryPromptRegistry.__init__","title":"__init__","text":"<pre><code>__init__(directory_path: str, *, force_reindex: bool = False)\n</code></pre> <p>Initialize the directory prompt registry.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>str</code> <p>Path to directory where prompts will be stored</p> required <code>force_reindex</code> <code>bool</code> <p>Whether to force rebuilding the index from disk</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If directory_path is not a directory</p>"},{"location":"python/#banks.registries.directory.DirectoryPromptRegistry.get","title":"get","text":"<pre><code>get(*, name: str, version: str | None = None) -&gt; Prompt\n</code></pre> <p>Retrieve a prompt by name and version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the prompt to retrieve</p> required <code>version</code> <code>str | None</code> <p>Version of the prompt (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>Prompt</code> <p>The requested Prompt object</p> <p>Raises:</p> Type Description <code>PromptNotFoundError</code> <p>If prompt doesn't exist</p>"},{"location":"python/#banks.registries.directory.DirectoryPromptRegistry.set","title":"set","text":"<pre><code>set(*, prompt: Prompt, overwrite: bool = False)\n</code></pre> <p>Store a prompt in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>Prompt</code> <p>The Prompt object to store</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing prompt</p> <code>False</code> <p>Raises:</p> Type Description <code>InvalidPromptError</code> <p>If prompt exists and overwrite=False</p>"},{"location":"python/#banks.registries.file.FilePromptRegistry","title":"banks.registries.file.FilePromptRegistry","text":"<p>A prompt registry storing all prompt data in a single JSON file.</p>"},{"location":"python/#banks.registries.file.FilePromptRegistry.__init__","title":"__init__","text":"<pre><code>__init__(registry_index: str) -&gt; None\n</code></pre> <p>Initialize the file prompt registry.</p> <p>Parameters:</p> Name Type Description Default <code>registry_index</code> <code>str</code> <p>Path to the JSON file that will store the prompts</p> required Note <p>Creates parent directories if they don't exist.</p>"},{"location":"python/#banks.registries.file.FilePromptRegistry.get","title":"get","text":"<pre><code>get(*, name: str, version: str | None = None) -&gt; Prompt\n</code></pre> <p>Retrieve a prompt by name and version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the prompt to retrieve</p> required <code>version</code> <code>str | None</code> <p>Version of the prompt (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>Prompt</code> <p>The requested Prompt object</p> <p>Raises:</p> Type Description <code>PromptNotFoundError</code> <p>If the requested prompt doesn't exist</p>"},{"location":"python/#banks.registries.file.FilePromptRegistry.set","title":"set","text":"<pre><code>set(*, prompt: Prompt, overwrite: bool = False) -&gt; None\n</code></pre> <p>Store a prompt in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>Prompt</code> <p>The Prompt object to store</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite an existing prompt</p> <code>False</code> <p>Raises:</p> Type Description <code>InvalidPromptError</code> <p>If prompt exists and overwrite=False</p>"},{"location":"python/#banks.registries.redis.RedisPromptRegistry","title":"banks.registries.redis.RedisPromptRegistry","text":"<p>A prompt registry that stores prompts in Redis.</p>"},{"location":"python/#banks.registries.redis.RedisPromptRegistry.__init__","title":"__init__","text":"<pre><code>__init__(redis_url: str = 'redis://localhost:6379', prefix: str = 'banks:prompt:') -&gt; None\n</code></pre> <p>Initialize the Redis prompt registry.</p> <p>Parameters:</p> Name Type Description Default <code>redis_url</code> <code>str</code> <p>Redis connection URL</p> <code>'redis://localhost:6379'</code> <code>prefix</code> <code>str</code> <p>Key prefix for storing prompts in Redis</p> <code>'banks:prompt:'</code>"},{"location":"python/#banks.registries.redis.RedisPromptRegistry.get","title":"get","text":"<pre><code>get(*, name: str, version: str | None = None) -&gt; Prompt\n</code></pre> <p>Get a prompt by name and version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the prompt</p> required <code>version</code> <code>str | None</code> <p>Version of the prompt (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>Prompt</code> <p>Prompt instance</p> <p>Raises:</p> Type Description <code>PromptNotFoundError</code> <p>If prompt doesn't exist</p>"},{"location":"python/#banks.registries.redis.RedisPromptRegistry.set","title":"set","text":"<pre><code>set(*, prompt: Prompt, overwrite: bool = False) -&gt; None\n</code></pre> <p>Store a prompt in Redis.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>Prompt</code> <p>Prompt instance to store</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing prompt</p> <code>False</code> <p>Raises:</p> Type Description <code>InvalidPromptError</code> <p>If prompt exists and overwrite=False</p>"},{"location":"registry/","title":"Prompt Registry","text":""},{"location":"registry/#prompt-registry-beta","title":"Prompt registry (BETA)","text":"<p>The Prompt Registry provides a storage API for managing versioned prompts. It allows you to store and retrieve prompts from different storage backends. Currently, Banks supports two storage implementations:</p> <ul> <li>Directory-based storage</li> <li>Redis-based storage</li> </ul>"},{"location":"registry/#usage","title":"Usage","text":"<pre><code>from banks import Prompt\nfrom banks.registries.directory import DirectoryPromptRegistry\nfrom pathlib import Path\n\n# Create a registry\nregistry = DirectoryPromptRegistry(Path(\"./prompts\"))\n\n# Create and store a prompt\nprompt = Prompt(\n    text=\"Write a blog post about {{topic}}\",\n    name=\"blog_writer\",\n    version=\"1.0\",\n    metadata={\"author\": \"John Doe\"}\n)\nregistry.set(prompt=prompt)\n\n# Retrieve a prompt\nretrieved_prompt = registry.get(name=\"blog_writer\", version=\"1.0\")\n</code></pre>"},{"location":"registry/#directory-registry","title":"Directory Registry","text":"<p>The DirectoryPromptRegistry stores prompts as individual files in a directory. Each prompt is saved as a <code>.jinja</code> file with the naming pattern <code>{name}.{version}.jinja</code>.</p> <pre><code># Initialize directory registry\nregistry = DirectoryPromptRegistry(\n    directory_path=Path(\"./prompts\"),\n    force_reindex=False  # Set to True to rebuild the index\n)\n</code></pre>"},{"location":"registry/#redis-registry","title":"Redis Registry","text":"<p>The RedisPromptRegistry stores prompts in Redis using a key-value structure.</p> <pre><code>from banks.registries.redis import RedisPromptRegistry\n\nregistry = RedisPromptRegistry(\n    redis_url=\"redis://localhost:6379\",\n    prefix=\"banks:prompt:\"\n)\n</code></pre>"},{"location":"registry/#common-features","title":"Common Features","text":"<p>Both implementations support:</p> <ul> <li>Versioning with automatic \"0\" default version</li> <li>Overwrite protection with <code>overwrite=True</code> option</li> <li>Metadata storage</li> <li>Error handling for missing/invalid prompts</li> </ul>"}]}